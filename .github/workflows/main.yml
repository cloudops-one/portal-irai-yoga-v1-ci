name: CI/CD Pipeline

permissions:
  actions: read
  contents: read

on:
  push:
    branches: ['**']
    tags: ['v*', '*.*.*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'preview'
        type: choice
        options:
        - preview
        - stage
        - production
      image-tag:
        description: 'Docker image tag'
        required: true
        default: 'latest'

env:
  REGISTRY_URL: '${{ secrets.HARBOR_REGISTRY }}'

jobs:
  validate-branch:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      docker_tag: ${{ steps.env.outputs.docker_tag }}
      branch_valid: ${{ steps.validation.outputs.valid }}
      domain: ${{ steps.domain.outputs.domain }}
      project_name: ${{ steps.project.outputs.project_name }}
      component: ${{ steps.project.outputs.component }}
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Extract project name from repository
        id: project
        run: |
          PROJECT_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2 | sed 's/-k8s//g' | sed 's/-deploy//g')
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "component=admin" >> $GITHUB_OUTPUT
        
      - name: Determine environment and tag
        id: env
        run: |
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            TAG="${GITHUB_REF#refs/tags/}"
            echo "docker_tag=$TAG" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "environment=stage" >> $GITHUB_OUTPUT
            echo "docker_tag=stage" >> $GITHUB_OUTPUT
          else
            echo "environment=preview" >> $GITHUB_OUTPUT
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
            echo "docker_tag=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          fi
          
      - name: Determine domain
        id: domain
        run: |
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            echo "domain=live-domain-config" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "domain=stage-domain-config" >> $GITHUB_OUTPUT
          else
            echo "domain=preview-domain-config" >> $GITHUB_OUTPUT
          
      - name: Validate branch name and tag
        id: validation
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          BRANCH_REGEX="^(feat|fix|chore|test|docs|refactor|ci|style|perf|build)/[0-9]{1,5}_[a-z0-9]+(-[a-z0-9]+)*$"
          
          if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            if [[ "$TAG_NAME" =~ ^(v)?[0-9]+\.[0-9]+\.[0-0]+$ ]]; then
              echo "valid=true" >> $GITHUB_OUTPUT
              echo "Tag $TAG_NAME is valid for live deployment"
            else
              echo "valid=false" >> $GITHUB_OUTPUT
              echo "Invalid tag format. Expected: v1.0.0 or 1.0.0"
              exit 1
            fi
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Main branch is valid for stage deployment"
          elif [[ "$BRANCH_NAME" =~ $BRANCH_REGEX ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Feature branch $BRANCH_NAME is valid for preview deployment"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "Branch name does not match required pattern"
            exit 1

  gitleaks-scan:
    needs: validate-branch
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Gitleaks Security Scan
        uses: cloudops-one/devops-ci/.github/actions/gitleaks-scan@main
        with:
          scan-path: '.'
          fail-on-leak: true
          config-path: '.gitleaks.toml'
          redact-secrets: true

  trivy-filesystem-scan:
    needs: [validate-branch, gitleaks-scan]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      - name: Run Trivy filesystem scan
        uses: cloudops-one/devops-ci/.github/actions/trivy-scan@main
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          scanners: 'vuln,secret,config'
          ignore-unfixed: 'false'

  sonarqube-scan:
    needs: [validate-branch, trivy-filesystem-scan]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Node.js
        uses: cloudops-one/setup-node@v1
        with:
          node-version: '20'
      - name: Install dependencies
        run: |
          if [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
      - name: Run Centralized SonarQube Scan
        uses: cloudops-one/devops-ci/.github/actions/sonarqube-scan@main
        with:
          sonar-token: ${{ secrets.SONARQUBE_TOKEN }}
          sonar-host-url: ${{ secrets.SONARQUBE_URL }}
          project-key: 'portal-irai-yoga-admin'
          project-name: 'Portal Irai Yoga Admin'
          docker-tag: ${{ needs.validate-branch.outputs.docker_tag }}
          branch-name: ${{ github.ref_name }}
          sources-path: src
          coverage-path: coverage/lcov.info

  code-coverage:
    needs: [validate-branch, sonarqube-scan]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      - name: Run Code Coverage
        uses: cloudops-one/devops-ci/.github/actions/code-coverage@main
        with:
          node-version: '20'

  compile:
    needs: code-coverage
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      - name: Compile application
        run: |
          echo "Running compilation step..."
          echo "Compilation completed successfully"

  react-build:
    needs: compile
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      - name: Build React application
        uses: cloudops-one/devops-ci/.github/actions/build-react@main
        with:
          node-version: '20'
          skip-husky: true
          generate-lockfile: true

  docker-build:
    needs: [validate-branch, react-build]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      - name: Validate Docker tag format
        id: validate-tag
        run: |
          TAG="${{ needs.validate-branch.outputs.docker_tag }}"
          if [[ -z "$TAG" ]]; then
            echo "❌ Docker tag is empty"
            exit 1
          fi
          if [[ ! "$TAG" =~ ^[a-zA-Z0-9][a-zA-Z0-9_.-]{0,127}$ ]]; then
            echo "❌ Invalid Docker tag format: $TAG"
            exit 1
          else
            echo "✅ Docker tag is valid: $TAG"
          fi
      - name: Build Docker image
        run: |
          IMAGE_TAG="portal-irai-yoga-admin:${{ needs.validate-branch.outputs.docker_tag }}"
          docker build -t $IMAGE_TAG .
      - name: Save Docker image
        run: |
          IMAGE_TAG="portal-irai-yoga-admin:${{ needs.validate-branch.outputs.docker_tag }}"
          docker save -o docker-image.tar $IMAGE_TAG
      - name: Upload Docker image
        uses: cloudops-one/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar
          retention-days: 1

  trivy-container-scan:
    needs: [validate-branch, docker-build]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker image
        uses: cloudops-one/download-artifact@v4
        with:
          name: docker-image
          path: .
      - name: Load Docker image
        run: |
          docker load -i docker-image.tar
      - name: Scan Docker image with Trivy
        uses: cloudops-one/devops-ci/.github/actions/trivy-scan@main
        with:
          scan-type: 'image'
          scan-ref: 'portal-irai-yoga-admin:${{ needs.validate-branch.outputs.docker_tag }}'
          severity: 'CRITICAL'
          scanners: 'vuln,secret,config'
          ignore-unfixed: 'true'

  docker-push:
    needs: [docker-build, trivy-container-scan, validate-branch]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker image
        uses: cloudops-one/download-artifact@v4
        with:
          name: docker-image
          path: .
      - name: Load Docker image
        run: |
          docker load -i docker-image.tar
      - name: Login to Docker Registry
        run: |
          echo "${{ secrets.HARBOR_PASSWORD }}" | docker login ${{ secrets.HARBOR_REGISTRY }} --username ${{ secrets.HARBOR_USERNAME }} --password-stdin
      - name: Tag and push Docker image
        run: |
          LOCAL_IMAGE="portal-irai-yoga-admin:${{ needs.validate-branch.outputs.docker_tag }}"
          REMOTE_IMAGE="${{ secrets.HARBOR_REGISTRY }}/portal-irai-yoga/admin:${{ needs.validate-branch.outputs.docker_tag }}"
          docker tag $LOCAL_IMAGE $REMOTE_IMAGE
          docker push "$REMOTE_IMAGE"
      - name: Logout from Docker Registry
        run: |
          docker logout ${{ secrets.HARBOR_REGISTRY }}

  deploy:
    needs: docker-push
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4

      - name: Set up kubectl
        uses: cloudops-one/action-doctl@main
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Save kubeconfig
        run: doctl kubernetes cluster kubeconfig save <cluster-name>

      - name: Deploy to Kubernetes
        run: |
          IMAGE_TAG="${{ secrets.HARBOR_REGISTRY }}/portal-irai-yoga/admin:${{ needs.validate-branch.outputs.docker_tag }}"
          NAMESPACE=irai-yoga-v1-live
          DEPLOYMENT=irai-yoga-v1-admin-live
          CONTAINER=irai-yoga-v1-admin-live
          kubectl set image deployment/$DEPLOYMENT $CONTAINER=$IMAGE_TAG -n $NAMESPACE
          kubectl rollout status deployment/$DEPLOYMENT -n $NAMESPACE
